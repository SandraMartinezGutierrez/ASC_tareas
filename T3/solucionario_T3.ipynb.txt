{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Tarea 3 (Pandas)\n",
    "\n",
    "Hora de entrega: Viernes 28 de Mayo, 11:59 pm\n",
    "\n",
    "Nombrar al archivo de la siguiente manera: Apellido_c√≥digo.  \n",
    "Ejemplo:  Solis_20060983\n",
    "\n",
    "Entregar la tarea en esta plantilla, no usar una adicional a esta. \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- Antes que nada, ¬°necesitamos nuestros datos! \n",
    "1. Ve a la p√°gina de microdatos del [INEI](http://iinei.inei.gob.pe/microdatos/). \n",
    "2. Ve a \"Consulta por encuestas\" y ve a ENAHO metodolog√≠a ACTUALIZADA. \n",
    "3. Elige aquella que dice \"Condiciones de Vida y Pobreza - ENAHO\" (la que no es panel). \n",
    "4. Elige el a√±o 2020, y en per√≠odo, elige la anual.   \n",
    "5. Descarga los **archivos CSV** del C√≥digo m√≥dulo 1 (Caracter√≠sticas de la vivienda y el hogar) y el m√≥dulo 34 (Sumarias - Variables Calculadas). \n",
    "\n",
    "Esta tarea est√° pensada en ser desarrollada con los CSV (no los .dta o .sav, que son los archivos de stata √≥ spss respectivamente).\n",
    "\n",
    "\n",
    "La ENAHO es una encuesta muy amplia que est√° distribuida en varios m√≥dulos. En esta tarea veremos c√≥mo podemos utilizar informaci√≥n de varios de estos m√≥dulos para sacar datos interesantes. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. Lee ambos archivos csv con pandas y as√≠gnales un nombre para que puedas trabajar con ambos como base de datos. (Si es que sale un error, es debido a que nuestras encuestas est√°n en espa√±ol y tienen caracteres como Àú de la √± o el acento. Por ello, a las opciones de lectura del csv, agrega la siguiente opci√≥n ``` encoding = \"latin-1\" ```. \n",
    "\n",
    "(No olvides importar pandas üêº)\n",
    "\n",
    "\n",
    "En caso tus columnas salgan con el nombre en may√∫scula, puedes correr el siguiente comando para cambiarlas a min√∫sculas:\n",
    "\n",
    "``` python3 \n",
    "df.columns= df.columns.str.lower()\n",
    "``` \n",
    "Donde `df` es el nombre del dataframe.   \n",
    "(En esta clase no ahondamos en el manejo de strings, pero `lower()` es un m√©todo de este tipo de variables para convertir el string a min√∫scula.)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/ccsuehara/opt/anaconda3/lib/python3.8/site-packages/IPython/core/interactiveshell.py:3146: DtypeWarning: Columns (322) have mixed types.Specify dtype option on import or set low_memory=False.\n",
      "  has_raised = await self.run_ast_nodes(code_ast.body, cell_name,\n"
     ]
    }
   ],
   "source": [
    "m1 = pd.read_csv(\"/Users/ccsuehara/Downloads/737-Modulo01/Enaho01-2020-100.csv\", sep = \",\" ,encoding = 'latin-1')\n",
    "m34 = pd.read_csv(\"/Users/ccsuehara/Downloads/737-Modulo34/Sumaria-2020.csv\", sep = \",\" ,encoding = 'latin-1')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "2. - ¬øCu√°les son las dimensiones de la sumaria? (o el n√∫mero de filas y columnas).\n",
    "   - ¬øCu√°les son las dimensiones del m√≥dulo de vivienda? (o el n√∫mero de filas y columnas)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(53423, 326)\n",
      "(34490, 174)\n"
     ]
    }
   ],
   "source": [
    "print(m1.shape)  ## Pod√≠a salir 331\n",
    "print(m34.shape) ## pod√≠a salir 179 columnas"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "3. En esta oportunidad no necesitaremos todas las variables de la ENAHO para hacer esta tarea. \n",
    "- Qued√©monos con las variables ``` CONGLOME VIVIENDA HOGAR MIEPERHO PERCEPHO POBREZA GASHOG2D INGHOG2D ``` de la sumaria. \n",
    "- Qued√©monos con las variables ``` CONGLOME VIVIENDA HOGAR RESULT NBI1 NBI2 NBI3 NBI4 NBI5 ``` del m√≥dulo de vivienda.\n",
    "\n",
    " \n",
    " Nota: cada una de las variables es:\n",
    "- MIEPERHO: n√∫mero de miembros del hogar. \n",
    "- PERCEPHO: n√∫mero de perceptores del hogar (que reciben un ingreso). \n",
    "- POBREZA: Pobreza monetaria seg√∫n la l√≠nea de pobreza. \n",
    "- GASHOG2D: Gasto bruto anual del hogar. \n",
    "- INGHOG2D: Ingreso anual neto total del hogar. \n",
    "\n",
    "Necesidades b√°sicas:\n",
    "- NBI1: vivienda inadecuada.\n",
    "- NBI2: hacinamiento\n",
    "- NBI3: vivienda sin servicios higi√©nicos\n",
    "- NBI4: hogares con  ni√±os que no asisten a la escuela.\n",
    "- NBI5: hogares con alta dependencia econ√≥mica \n",
    "\n",
    "CONGLOME, VIVIENDA y HOGAR son los identificadores √∫nicos a nivel de hogar (como un key id)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "m34_s = m34[['CONGLOME', 'VIVIENDA', 'HOGAR', 'MIEPERHO', 'PERCEPHO', 'POBREZA', 'GASHOG2D', 'INGHOG2D']]\n",
    "m1_s = m1[['CONGLOME', 'VIVIENDA', 'HOGAR', 'RESULT', 'NBI1', 'NBI2', 'NBI3', 'NBI4', 'NBI5']]\n",
    "# √≥\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "m34_s = m34.loc[:, ['CONGLOME', 'VIVIENDA', 'HOGAR', 'MIEPERHO', 'PERCEPHO', 'POBREZA', 'GASHOG2D', 'INGHOG2D']]\n",
    "m1_s = m1.loc[:, ['CONGLOME', 'VIVIENDA', 'HOGAR', 'RESULT', 'NBI1', 'NBI2', 'NBI3', 'NBI4', 'NBI5']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "m1_s.columns= m1_s.columns.str.lower()\n",
    "m34_s.columns= m34_s.columns.str.lower()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4. El m√≥dulo vivienda incluye todos los hogares que entraron en el marco muestral, incluso aquellos que no participaron en la ENAHO por diversos motivos. Para eliminar estas viviendas, qued√©monos con aquellas cuyo ``` RESULT``` sea igual a 1 √≥ 2. Almacena este resultado para despu√©s."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "##Ccualquiera de estas: \n",
    "\n",
    "#1\n",
    "#filtro = (m1_s['result'] == 1) | (m1_s['result'] == 2)\n",
    "\n",
    "#m1_s = m1_s[filtro]\n",
    "\n",
    "#√≥\n",
    "#2\n",
    "#filtro = m1_s['result'] <= 2\n",
    "\n",
    "#m1_s = m1_s[filtro]\n",
    "\n",
    "#√≥ \n",
    "#3\n",
    "#filtro = m1_s['result'] <= 2\n",
    "#m1_s = m1_s.loc[filtro ]\n",
    "\n",
    "#√≥\n",
    "#4\n",
    "filtro = m1_s['result'].isin([1,2])\n",
    "\n",
    "m1_s = m1_s.loc[filtro]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "5. Queremos calcular una serie de variables (√≥ columnas nuevas):  \n",
    "En sumaria: \n",
    "- Queremos el n√∫mero de miembros dependientes del hogar . Estos son el n√∫mero de personas que no perciben un ingreso √≥ la diferencia entre el total de miembros y el total de perceptores. \n",
    "- Queremos el ingreso mensual promedio por perceptor del hogar.\n",
    "- Queremos la diferencia  entre ingreso y gasto del hogar"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "m34_s['dep'] = m34_s.eval('mieperho - percepho')\n",
    "m34_s['percepho_ing_men'] = m34_s.eval('inghog2d / (12 * percepho)')\n",
    "m34_s['dif'] = m34_s.eval('inghog2d - gashog2d')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "6. La variable de `pobreza`, en la sumaria, est√° codificada como integers 1, 2 y 3. Esto corresponde a:  \n",
    "`1`: hogar pobre extremo  \n",
    "`2`: hogar pobre no extremo  \n",
    "`3`: hogar no  pobre  \n",
    "\n",
    "En base a esta variable, crea dos variables m√°s:\n",
    "1. Una variable que tenga `'pobre extremo'`, `'pobre no extremo'` y `'no pobre'` en vez  de 1, 2, 3.\n",
    "2. Una variable que tenga `'pobre'` y `'no pobre'` (√≥ que englobe a los hogares pobres y pobres no extremos).\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "reemplazo_1 = {1: 'pobre extremo', 2: 'pobre no extremo', 3: 'no pobre'}\n",
    "reemplazo_2 = {1: 'pobre', 2: 'pobre', 3: 'no pobre'}\n",
    "\n",
    "m34_s['pobreza_1'] = m34_s['pobreza'] \n",
    "m34_s['pobreza_2'] = m34_s['pobreza']\n",
    "\n",
    "m34_s.replace({'pobreza_1': reemplazo_1}, inplace = True)\n",
    "m34_s.replace({'pobreza_2': reemplazo_2}, inplace = True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "7. Queremos saber el promedio de ingresos de los hogares (inghog2d) por nivel de pobreza. Haz un `groupby` para averiguar esto. \n",
    "\n",
    "\n",
    "(Por ejemplo, todos los hogares pobres extremos tendr√°n un √∫nico promedio, y as√≠ con las 2 categor√≠as de pobreza adicionales). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>pobreza_1</th>\n",
       "      <th>inghog2d</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>no pobre</td>\n",
       "      <td>27723.537681</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>pobre extremo</td>\n",
       "      <td>9124.563670</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>pobre no extremo</td>\n",
       "      <td>13348.526738</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "          pobreza_1      inghog2d\n",
       "0          no pobre  27723.537681\n",
       "1     pobre extremo   9124.563670\n",
       "2  pobre no extremo  13348.526738"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(m34_s[['inghog2d','pobreza_1']].\n",
    "groupby('pobreza_1').\n",
    "mean().reset_index()) ## me sale un numero diferente al de uds pero este es el c√≥digo"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "8. ¬°Ahora uniremos los datos!  \n",
    "Pero antes un check de sanidad: Verifica que el n√∫mero  de filas de ambas bases de datos son las mismas (acu√©rdate que filtramos las observaciones por `result`).  La ENAHO recolecta informaci√≥n de estos 34,490 hogares a trav√©s de todos sus m√≥dulos. Para utilizar estos m√≥dulos a la vez, realizaremos una \"uni√≥n\" (merge).   \n",
    "\n",
    "Une ambas bases con un _inner merge_. Recuerda que el id que identifica a cada hogar se compone de ` conglome vivienda hogar`.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "merged = pd.merge(m1_s,\n",
    "                  m34_s,\n",
    "                  on = ['conglome', 'vivienda', 'hogar'],\n",
    "                  how = 'inner',\n",
    "                  indicator = True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "9. Haz un ```groupby``` que agrupe (`agg`) los datos por nivel de pobreza  y la nbi1. Queremos hallar el promedio y la mediana de los ingresos (inghog2d) y los gastos (gashog2d) por el producto cartesiano de las categor√≠as de estas 2 variables - pobreza y nbi 1 -. \n",
    "\n",
    "El producto cartesiano es tan s√≥lo todas las posibles combinaciones entre categor√≠as. \n",
    "En este caso, tendremos:\n",
    "- pobre extremo con nbi1\n",
    "- pobre extremo sin nbi1\n",
    "- pobre no extremo con nbi1\n",
    "- pobre no extremo sin nbi1\n",
    "- no pobre con nbi1\n",
    "- no pobre sin nbi1\n",
    "\n",
    "(Este es un  ejemplo de c√≥mo, al cruzar un indicador de pobreza monetaria -pobreza- y pobreza multidimensional-nbis-, podemos seguir observando brechas)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "medidas = ['mean', 'median']\n",
    "\n",
    "dict_agg = {'inghog2d': medidas,\n",
    "            'gashog2d': medidas}\n",
    "\n",
    "grpby = (merged.groupby(['pobreza_1','nbi1']).\n",
    "         agg(dict_agg).\n",
    "         reset_index())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "10. Crea una variable que nos informe sobre los hogares que tienen las 5 nbis. Esta tomar√° el valor de 1 si tiene las 5 nbis, 0 en caso contrario (as√≠  tenga 4, 3). \n",
    "\n",
    "Calcula el promedio de miembros dependientes por cada categor√≠a de esta nueva variable. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "tip = 'int'\n",
    "\n",
    "cambio_dtype = {'nbi1': tip,\n",
    "              'nbi2': tip,\n",
    "              'nbi3': tip,\n",
    "              'nbi4': tip,\n",
    "              'nbi5': tip}\n",
    "merged = merged.astype(cambio_dtype)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "merged['total_nbis'] = merged.eval('nbi1 + nbi2 + nbi3 + nbi4 + nbi5')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "merged['tiene_5nbis'] = 0\n",
    "merged.loc[merged['total_nbis'] == 5, 'tiene_5nbis'] = 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>tiene_5nbis</th>\n",
       "      <th>dep</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0</td>\n",
       "      <td>1.423688</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   tiene_5nbis       dep\n",
       "0            0  1.423688"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(merged.\n",
    " groupby('tiene_5nbis').\n",
    " agg({'dep': 'mean'}).\n",
    " reset_index())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "11. Cr√©dito extra: \n",
    "\n",
    "Guarda el dataframe del resultado del ejercicio 9 como un csv. (No es necesario adjuntar este csv, con  que el bloque haya corrido est√° bien). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "grpby.to_csv('carla/folder/cuadrito.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Tarea terminada**    ‚îó‚îÉ„Éª ‚ñ† „Éª‚îÉ‚îõ "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
